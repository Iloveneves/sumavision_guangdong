/**
 \file
 \brief Surface模块头文件
 \author Shenzhen Hisilicon Co., Ltd.
 \date 2008-2018
 \version 1.0
 \author s37678
 \date 2008-5-13
 */

#ifndef __HI_GO_SURFACE_H__
#define __HI_GO_SURFACE_H__

#include "hi_go_comm.h"
#ifdef __cplusplus
extern "C" {
#endif

/***************************** Macro Definition ******************************/
/** \addtogroup      H_3_3 */
/** @{ */  /** <!-- 【Surface模块错误码】 */

typedef enum
{
    HIGO_PF_CLUT8 = 0,  /**< 调色板 */
    HIGO_PF_CLUT1,
    HIGO_PF_CLUT4,
    HIGO_PF_4444,       /**< 一个像素占16bit，ARGB每分量占4bit，按地址由高至低排列 */
    HIGO_PF_0444,       /**< 一个像素占16bit，ARGB每分量占4bit，按地址由高至低排列, A分量不起作用 */

    HIGO_PF_1555,       /**< 一个像素占16bit，RGB每分量占5bit，A分量1bit，按地址由高至低排列 */
    HIGO_PF_0555,       /**< 一个像素占16bit，RGB每分量占5bit，A分量1bit，按地址由高至低排列, A分量不起作用 */
    HIGO_PF_565,        /**< 一个像素占16bit，RGB每分量分别占5bit、6bit和5bit，按地址由高至低排列 */
    HIGO_PF_8565,       /**< 一个像素占24bit，ARGB每分量分别占8bit, 5bit、6bit和5bit，按地址由高至低排列 */
    HIGO_PF_8888,       /**< 一个像素占32bit，ARGB每分量占8bit，按地址由高至低排列 */
    HIGO_PF_0888,       /**< 一个像素占24bit，ARGB每分量占8bit，按地址由高至低排列，A分量不起作用 */

    HIGO_PF_YUV400,     /**< 海思定义的semi-planar YUV 400格式 */    
    HIGO_PF_YUV420,     /**< 海思定义的semi-planar YUV 420格式 */
    HIGO_PF_YUV422,     /**< 海思定义的semi-planar YUV 422格式  水平采样格式*/
    HIGO_PF_YUV422_V,   /**< 海思定义的semi-planar YUV 422格式  垂直采样格式*/    
    HIGO_PF_YUV444,     /**< 海思定义的semi-planar YUV 444格式 */
    
	HIGO_PF_A1, 
	HIGO_PF_A8,
        
    HIGO_PF_YUV888,
    HIGO_PF_YUV8888,

    HIGO_PF_BUTT
} HIGO_PF_E;
/** @} */  /*! <!-- Macro Definition end */

/*************************** Structure Definition ****************************/
/** \addtogroup      H_2_3_3_7 */
/** @{ */  /** <!-- 【Surface】 */
/** 分量类型 */
typedef enum
{
    HIGO_PDFORMAT_RGB = 0,
    HIGO_PDFORMAT_RGB_PM,   /**< pre-multiplied */
    HIGO_PDFORMAT_Y,
    HIGO_PDFORMAT_UV,
    HIGO_PDFORMAT_UV_LE,    

    HIGO_PDFORMAT_BUTT
} HIGO_PDFORMAT_E;

typedef struct
{
    HIGO_PDFORMAT_E Format;     /**< 分量类型 */
    HI_VOID*        pData;      /**< 分量虚拟地址指针 */
    HI_VOID*        pPhyData;   /**< 分量物理地址指针 */    
    HI_U32          Pitch;      /**< 分量行宽 */
    HI_U32          Bpp;        /**< bytes per pixel */
    HI_U32          Offset;
} HIGO_PIXELDATA_S;


/** 最大数据分量数 */
#define MAX_PARTPIXELDATA 3


/**下面同步模式可以组合使用，不自动同步方式有用 */
typedef enum 
{
    HIGO_SYNC_MODE_CPU = 0x01, /*同步，下一步需要进行CPU操作*/
    HIGO_SYNC_MODE_TDE = 0x02, /*同步，下一步需要进行2D加速操作*/
    HIGO_SYNC_MODE_BUTT,
} HIGO_SYNC_MODE_E;


typedef enum
{
    HIGO_MEMTYPE_MMZ = 0,       /**< 使用MMZ内存进行创建 */
    HIGO_MEMTYPE_OS,            /**< 使用系统内存进行创建 */
    HIGO_MEMTYPE_BUTT
}HIGO_MEMTYPE_E;

typedef enum 
{
	HIGO_OWNER_USER = 0,        /**< 由用户进行管理，需要用户自行分配内存，销毁内存 */
	HIGO_OWNER_HIGO,            /**< 由HIGO进行管理，用户不需要管理内存 */
	HIGO_OWNER_BUTT
}HIGO_OWNER_E;

typedef struct
{
    HI_S32 Width;                               /**< surface宽度 */
    HI_S32 Height;                              /**< surface高度 */
    HIGO_PF_E PixelFormat;                      /**< surface像素格式*/
    HI_U32   Pitch[MAX_PARTPIXELDATA];          /**< surface行间距离*/
    HI_CHAR* pPhyAddr[MAX_PARTPIXELDATA];       /**< surface物理地址*/
    HI_CHAR* pVirAddr[MAX_PARTPIXELDATA];       /**< surface虚拟地址*/
    HIGO_MEMTYPE_E MemType;                     /**< surface内存类型*/
}HIGO_SURINFO_S;

typedef struct
{
    HI_S32 Width;                               /**< surface宽度 */
    HI_S32 Height;                              /**< surface高度 */
    HIGO_PF_E PixelFormat;                      /**< surface像素格式*/
    HI_U32   Pitch[MAX_PARTPIXELDATA];          /**< surface行间距离，
                                                     Pitch[0]表示RGB格式行间距， 或者Semi-planner的Y分量的行间距
                                                     Pitch[1]表示Semi-planner的C分量的行间距
                                                     Pitch[2]暂时不使用。
                                                     */
    HI_CHAR* pPhyAddr[MAX_PARTPIXELDATA];       /**< surface物理地址
                                                     pPhyAddr[0]表示RGB格式物理地址， 或者Semi-planner的Y分量的物理地址
                                                     pPhyAddr[1]表示Semi-planner的C分量的物理地址
                                                */
    HI_CHAR* pVirAddr[MAX_PARTPIXELDATA];       /**< surface虚拟地址
                                                     pVirAddr[0]表示RGB格式虚拟地址， 或者Semi-planner的Y分量的虚拟地址
                                                     pVirAddr[1]表示Semi-planner的C分量的虚拟地址
                                                */
    HIGO_MEMTYPE_E MemType;                     /**< surface内存类型*/
    HIGO_OWNER_E   MemOwner;                    /**< 内存的来源,例如是用户分配,还是HIGO分配*/
}HIGO_SURINFOEX_S;

/** 数据分量结构 */
typedef HIGO_PIXELDATA_S HI_PIXELDATA[MAX_PARTPIXELDATA];

/** @} */  /*! <!-- Structure Definition end */

/********************** Global Variable declaration **************************/

/******************************* API declaration *****************************/
/** \addtogroup      H_1_3_3_7 */
/** @{ */  /** <!-- 【surface】 */

/** 
\brief 初始化Surface
\attention \n
::HI_GO_Init已经包含对该接口的调用
\param 无

\retval ::HI_SUCCESS
\retval ::HI_FAILURE

\see \n
::HI_GO_DeinitSurface
*/
HI_S32 HI_GO_InitSurface(HI_VOID);

/** 
\brief 去初始化Surface
\attention \n
::HI_GO_Deinit已经包含对该接口的调用
\param 无

\retval ::HI_SUCCESS
\retval ::HIGO_ERR_NOTINIT

\see \n
::HI_GO_InitSurface
*/
HI_S32 HI_GO_DeinitSurface(HI_VOID);

/** 
\brief 设置surface的alpha值
\attention \n
无
\param[in]  Surface Surface句柄
\param[in]  Alpha Alpha值，范围是0-255。0表示透明，255表示不透明

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_LOCKED
\retval ::HIGO_ERR_INVHANDLE

\see \n
::HI_GO_GetSurfaceAlpha
*/
HI_S32 HI_GO_SetSurfaceAlpha(HI_HANDLE Surface, HI_U8 Alpha);

/** 
\brief 获取surface的alpha值
\attention \n
无
\param[in]  Surface Surface句柄
\param[out] pAlpha 接收alhpa值的空间指针，不能为空

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NULLPTR

\see \n
::HI_GO_SetSurfaceAlpha
*/
HI_S32 HI_GO_GetSurfaceAlpha(HI_HANDLE Surface, HI_U8* pAlpha);

/** 
\brief 设置是否使能surface的colorkey
\attention \n
无
\param[in] Surface Surface句柄
\param[in] Enable 是否使能colorKey。HI_TRUE：使能；HI_FALSE：不使能

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_INVHANDLE

\see \n
无
*/
HI_S32 HI_GO_EnableSurfaceColorKey(HI_HANDLE Surface, HI_BOOL Enable);

/** 
\brief 设置surface的colorKey值
\attention \n
无
\param[in] Surface Surface句柄
\param[in] ColorKey Colorkey值, 如果是RGB格式就使用全部按照32bit来进行填充，如果是CLUT格式就使用颜色索引来填充。

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_LOCKED
\retval ::HIGO_ERR_INVHANDLE

\see \n
::HI_GO_GetSurfaceColorKey
*/
HI_S32 HI_GO_SetSurfaceColorKey(HI_HANDLE Surface, HI_COLOR ColorKey);

/** 
\brief 获取surface的colorkey值
\attention \n
无
\param[in]  Surface Surface句柄
\param[out] pColorKey 接收colorkey值的空间指针，不可为空

\retval ::HI_SUCCESS
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NULLPTR
\retval ::HIGO_ERR_NOCOLORKEY

\see \n
::HI_GO_SetSurfaceColorKey
*/
HI_S32 HI_GO_GetSurfaceColorKey(HI_HANDLE Surface, HI_COLOR* pColorKey);

/** 
\brief 设置Surface的调色板
\attention \n
无
\param[in] Surface Surface句柄
\param[in] Palette 调色板

\retval ::HI_SUCCESS
\retval ::HIGO_ERR_LOCKED
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_INVSURFACEPF

\see \n
::HI_GO_GetSurfaceColorKey
*/
HI_S32 HI_GO_SetSurfacePalette(HI_HANDLE Surface, const HI_PALETTE Palette);

/** 
\brief 获取surface的调色板
\attention \n
无
\param[in]  Surface Surface句柄
\param[out] Palette 接收调色板的空间指针 

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_INVSURFACEPF

\see \n
::HI_GO_SetSurfacePalette
*/
HI_S32 HI_GO_GetSurfacePalette(HI_HANDLE Surface, HI_PALETTE Palette);

/** 
\brief 锁定surface，获取其内存指针
\attention \n
访问surface内容前需要调用该接口锁定surface \n
不能对同一surface重复锁定
\param[in] Surface Surface句柄
\param[out] pData 与内存访问相关的像素格式信息
\param[in] bSync  是否同步

\retval ::HI_SUCCESS
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_LOCKED

\see \n
::HI_GO_UnlockSurface
*/
HI_S32 HI_GO_LockSurface(HI_HANDLE Surface, HI_PIXELDATA pData, HI_BOOL bSync);


/** 
\brief 解锁定surface
\attention \n
对surface内容访问结束后，要及时调用该接口解锁定surface
\param[in] Surface Surface句柄

\retval ::HI_SUCCESS
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NOTLOCKED

\see \n
::HI_GO_LockSurface
*/
HI_S32 HI_GO_UnlockSurface(HI_HANDLE Surface);

/** 
\brief 获取surface尺寸
\attention \n
pWidth与pHeight不能同时为空
\param[in]  Surface Surface句柄
\param[out]  pWidth Surface宽度输出地址，不可为空
\param[out]  pHeight Surface高度输出地址，不可为空

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NULLPTR 

\see \n
无
*/
HI_S32 HI_GO_GetSurfaceSize(HI_HANDLE Surface, HI_S32* pWidth, HI_S32* pHeight);

/** 
\brief 获取surface像素格式
\attention \n
无
\param[in]  Surface Surface句柄
\param[out] pPixelFormat 像素格式输出地址，不可为空

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NULLPTR

\see \n
无
*/
HI_S32 HI_GO_GetSurfacePixelFormat(HI_HANDLE Surface, HIGO_PF_E* pPixelFormat);

/** 
\brief 将用户的内存封装成surface
\attention \n
pSurInfo所有属性都必须设置正确,支持输入的像素格式为RGB格式，clut8格式，以及YUV semi-planner格式。

\param[in]  pSurInfo 用户内存信息，不可为空
\param[out] pSurface 句柄信息，不可为空

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NULLPTR
\retval ::HIGO_ERR_INVSURFACESIZE
\retval ::HIGO_ERR_INVSURFACEPF
\retval ::HIGO_ERR_INVPARAM
\retval ::HIGO_ERR_NOTINIT
\retval ::HIGO_ERR_NOMEM

\see \n
无
*/
HI_S32 HI_GO_CreateSurfaceFromMem(const HIGO_SURINFO_S *pSurInfo, HI_HANDLE * pSurface);

/** 
\brief 创建内存surface
\attention \n
不能创建::HIGO_PF_CLUT1、::HIGO_PF_CLUT4、::HIGO_PF_YUV420、::HIGO_PF_YUV422格式的surface

\param[in] Width Surface宽度
\param[in] Height Surface高度
\param[in] PixelFormat Surface像素格式
\param[out] pSurface Surface句柄

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NOTINIT
\retval ::HIGO_ERR_NULLPTR
\retval ::HIGO_ERR_INVSURFACESIZE
\retval ::HIGO_ERR_INVSURFACEPF
\retval ::HIGO_ERR_NOMEM

\see \n
::HI_GO_FreeSurface
*/
HI_S32 HI_GO_CreateSurface(HI_S32 Width, HI_S32 Height, HIGO_PF_E PixelFormat, HI_HANDLE* pSurface);

/** 
\brief 创建子surface，子surface与其父surface共享同一块内存
\attention \n
无

\param[in] Surface 父surface句柄
\param[in] pRect 子surface在父surface中的区域，不可为空
\param[out] pSubSurface 子surface句柄，不可为空

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_NOTINIT
\retval ::HIGO_ERR_NULLPTR
\retval ::HIGO_ERR_OUTOFBOUNDS
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_UNSUPPORTED
\retval ::HIGO_ERR_NOMEM

\see \n
::HI_GO_FreeSurface
*/
HI_S32 HI_GO_CreateSubSurface(HI_HANDLE Surface, const HI_RECT *pRect, HI_HANDLE* pSubSurface);


/** 
\brief 销毁surface
\attention \n
无
\param[in] Surface Surface句柄

\retval ::HI_SUCCESS
\retval ::HIGO_ERR_NOTINIT
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_INUSE

\see \n
::HI_GO_CreateSurface \n
::HI_GO_DecImgData
*/
HI_S32 HI_GO_FreeSurface(HI_HANDLE Surface);


/**
\brief 允许针对surface的绘图操作是否需要自动同步。
\attention \n
     surface创建时，默认是自动同步的。同步的意思是: 使用TDE绘制之前，需要等CPU的绘制在cache的内容\n
     更新到surface的内存中，使用CPU绘制之前，需要等TDE绘制完成。
     该接口对所有surface的操作都生效
     
\param[in] hSurface Surface句柄，该函数内暂时没有用到
\param[in] bAutoSync 是否自动动步

\retval ::HI_SUCCESS
\retval ::HIGO_ERR_INVHANDLE

\see \n
无
*/
HI_S32 HI_GO_EnableSurfaceAutoSync(HI_HANDLE hSurface, HI_BOOL bAutoSync);



/**
\brief 同步surface,同步意义在于保证CPU或2D加速硬件绘制内容已经更新到surface的内存中
\attention \n
如果调用::HI_GO_EnableSurfaceAutoSync禁止自动动步，则在使用TDE或CPU绘制时，调用该函数保证同步，\n
否则绘制将不正确。
\param[in] hSurface Surface句柄，暂时无用
\param[in] mode 同步模式，参考::HIGO_SYNC_MODE_E

\retval ::HI_SUCCESS
\retval ::HIGO_ERR_INVHANDLE

\see \n
无
*/
HI_S32 HI_GO_SyncSurface(HI_HANDLE hSurface, HIGO_SYNC_MODE_E mode);


/**
\brief 设置surface的名字，通过设置surface名字，在命令行输入 cat /proc/higo 可以查看到该surface
的内部信息，包括内存占用，宽高，像素格式
\attention \n
名字最长为16个字符，包括结尾符'\0'。

\param[in] hSurface surface句柄 
\param[in] pName surface名字串

\retval ::HI_SUCCESS
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NULLPTR

\see \n
无
*/
HI_S32 HI_GO_SetSurfaceName(HI_HANDLE hSurface, const HI_CHAR* pName);


/**
\brief 获取surface的名字
\attention \n
名字最长为16个字符，包括结尾符'\0'。

\param[in] hSurface surface句柄
\param[in] pNameBuf 保存名字的buffer
\param[in] BufLen buffer 长度

\retval ::HI_SUCCESS
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_INVPARAM

\see \n
无
*/
HI_S32 HI_GO_GetSurfaceName(HI_HANDLE hSurface,  HI_CHAR* pNameBuf, HI_U32 BufLen);



/** 
\brief 获取内存类型
\attention \n
 
\param[in]  Surface Surface句柄
\param[out]  pMemType 内存类型指针，不可为空

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NULLPTR 

\see \n
无
*/
HI_S32 HI_GO_GetSurfaceMemType(HI_HANDLE Surface, HIGO_MEMTYPE_E *pMemType);


/** 
\brief 查询内存类型
\attention \n
 
\param[in]   Surface  surface
\param[out]  pOwner   Owner类型指针，不可为空

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NULLPTR 

\see \n
无
*/
HI_S32 HI_GO_GetSurfaceOwner(HI_HANDLE Surface, HIGO_OWNER_E *pOwner);

/** 
\brief 创建OS类型内存
即逻辑上是连续的一块内存区域（但物理上不一定连续，如用户直接调用malloc分配的区域），
这不能被硬件所识别，但在HIGO某些组件中是可以被识别的，该类型可以某种程度上缓解MMZ内存的不足

\attention \n
 
目前对于os 类型的surface，仅具有以下的使用范围：
1).在无缩放，无格式转换下，支持在bmp，gif，png软件解码中使用	
2).支持在RGB格式的surface的编码成bmp中使用
3).支持将text输出到该类型的surface
4).MMZ类型与OS类型surface之间的转换可以通过HI_GO_Blit进行，但是HI_GO_Blit函数仅支持HIGO_BLTOPT_S 变量={0}，
	 或者设置Colorkey相关操作，或者两种surface在RGB格式间进行blit，其它组合参数不支持。
5).MemOwner为HIGO_OWNER_USER，支持格式包括YUV(semi-planner), RGB，CLUT8格式格式，否则支持RGB和CLUT8格式。
下面解析一下怎么创建YUV几种常用格式的surface：
	HI_U32 u32AlignWidth_Y,u32AlignHeight_Y; //Y分量对齐后的大小
	HI_U32 u32AlignWidth_C,u32AlignHeight_C; //UV分量对齐后的大小
	HI_U32 uExpectWidth,uExpectHeight;       //原图片的大小或期望的图片的大小
	HIGO_PF_E szPixelFormat;                 //原图片的像素格式或期望的图片的像素格式，如HIGO_PF_YUV400,HIGO_PF_YUV420,HIGO_PF_YUV422,HIGO_PF_YUV422_V,HIGO_PF_YUV444
	HIGO_SURINFOEX_S SurfaceInfoEx = {0};
    
	SurfaceInfoEx.Width = uExpectWidth;
	SurfaceInfoEx.Height = uExpectHeight;
	SurfaceInfoEx.PixelFormat = szPixelFormat;
	SurfaceInfoEx.MemType = HIGO_MEMTYPE_MMZ;
  	SurfaceInfoEx.MemOwner = HIGO_OWNER_USER;
    	
	SurfaceInfoEx.Pitch[0] = u32AlignWidth_Y;
	SurfaceInfoEx.pPhyAddr[0] = HI_MMZ_New(SurfaceInfoEx.Pitch[0]*u32AlignHeight_Y, 4, NULL, "higoSurface");
	SurfaceInfoEx.pVirAddr[0] = HI_MMZ_Map((HI_U32)SurfaceInfoEx.pPhyAddr[0], 0);
    
	SurfaceInfoEx.Pitch[1] = u32AlignWidth_C;
	SurfaceInfoEx.pPhyAddr[1] = HI_MMZ_New(SurfaceInfoEx.Pitch[1]*u32AlignHeight_C, 4, NULL, "higoSurfaceCbCr");
	SurfaceInfoEx.pVirAddr[1] = HI_MMZ_Map((HI_U32)SurfaceInfoEx.pPhyAddr[1], 0);
	
	ret = HI_GO_CreateSurfaceEx(&SurfaceInfoEx, &picSurface);

---------------------------------------------------------------------------------------
下面说明一下根据szPixelFormat说明u32AlignWidth_Y，u32AlignHeight_Y，u32AlignWidth_C，u32AlignHeight_C的取值：
1 ) YUV400情况：
	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //作128 byte对齐
	u32AlignHeight_Y  = (uExpectHeight + 7) + (~(7));	      //作8 byte对齐
	u32AlignWidth_C   = 0;
	u32AlignHeight_C  = 0;
2 ) YUV420情况：
	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //作128 byte对齐
	u32AlignHeight_Y  = (uExpectHeight + 15) + (~(15));	      //作16 byte对齐
	u32AlignWidth_C   = u32AlignWidth_Y;
	u32AlignHeight_C  = u32AlignHeight_Y / 2;
3 ) YUV422情况：
	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //作128 byte对齐
	u32AlignHeight_Y  = (uExpectHeight + 7) + (~(7));	      //作8 byte对齐
	u32AlignWidth_C   = u32AlignWidth_Y;
	u32AlignHeight_C  = u32AlignHeight_Y;
4 ) YUV422_V情况：
	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //作128 byte对齐
	u32AlignHeight_Y  = (uExpectHeight + 15) + (~(15));	      //作16 byte对齐
	u32AlignWidth_C   = u32AlignWidth_Y * 2;
	u32AlignHeight_C  = u32AlignHeight_Y / 2;
5 ) YUV444情况：
	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //作128 byte对齐
	u32AlignHeight_Y  = (uExpectHeight + 7) + (~(7));	      //作8 byte对齐
	u32AlignWidth_C   = u32AlignWidth_Y * 2;
	u32AlignHeight_C  = u32AlignHeight_Y;
\param[in]   pSurInfo      surface信息指针，不可为空
\param[out]  pSurface      surface指针，不可为空

\retval ::HI_SUCCESS 
\retval ::HIGO_ERR_INVHANDLE
\retval ::HIGO_ERR_NULLPTR 

\see \n
无
*/
HI_S32 HI_GO_CreateSurfaceEx(const HIGO_SURINFOEX_S  *pSurInfo, HI_HANDLE* pSurface);

/** @} */  /*! <!-- API declaration end */

#ifdef __cplusplus
}
#endif
#endif /* __HI_GO_SURFACE_H__ */
